* Holy grail

** What is it?

This demonstrates the *holy grail* workflow for web development the way I envision it: an auto-restartable back-end in the REPL + a hot-reloadable front-end in the browser.

This workflow is built on top of [[http://boot-clj.com/][Boot]], a build tool, and [[https://github.com/danielsz/system/tree/master/examples/boot][system]], a component library.  

** Installation
Clone this repo, cd into it and start the development pipeline build.
#+BEGIN_SRC shell
$ git clone git@github.com:danielsz/holygrail.git
$ cd holygrail
$ boot dev
#+END_SRC

** Principle of operation
*** Manual
You want to operate with a REPL, start the system, and reset it when you make changes.

Compose a build pipeline: 

#+BEGIN_SRC clojure
(deftask dev
  "Run a restartable system in the Repl"
  []
  (comp
   (environ :env {:http-port 3000})
   (watch)
   (system :sys #'dev-system)
   (reload)
   (cljs)
   (repl :server true)))
#+END_SRC

Start it: 

#+BEGIN_SRC shell
$ boot dev
#+END_SRC

 Pay attention to the line that says:
#+BEGIN_SRC shell
nREPL server started on port 49722 on host 127.0.0.1 - nrepl://127.0.0.1:49722
#+END_SRC

Launch your favorite editor, and connect to the headless REPL (~M-x cider-connect~ in Emacs works great). Then
type:
#+BEGIN_SRC clojure
(go)
#+END_SRC

Your web app is started and listening at [[http://localhost:3000]]. When you make changes that require a system restart, type in the REPL: 

#+BEGIN_SRC clojure
(reset)
#+END_SRC

*** Automatic

The ~boot-system~ task allows you to automate all of the above. 

#+BEGIN_SRC clojure
(system :sys #'dev-system :auto-start true :hot-reload true :files ["handler.clj"])
#+END_SRC

The ~auto-start~ option takes care of starting the app the first time. Your system will automatically be reset after editing ~handler.clj~. Changes elsewhere do not require a system restart, and are available via namespace reloading everytime you save your work. 

*Note:* The ~build.boot~ in this repo already contains those options. 

** Demo

>  Well, on second thought, let's not go to Camelot -- it is
a silly place.
> - King Arthur

#+BEGIN_HTML
<iframe width="420" height="315" src="https://www.youtube.com/embed/9loJGzCMne8" frameborder="0" allowfullscreen></iframe>
#+END_HTML
Let’s demonstrate how liberating the experience can be when developing a web app in this way. 

Open the file *src/clj/real_time/handler.clj*. Let’s add a route: 
#+BEGIN_SRC clojure
(defroutes app-routes
  (GET "/" [] (-> (resp/resource-response "index.html")
                     (resp/content-type "text/html")))
(POST "/quiz" req (str "<h1>Nice try</h1>"))  ;; let’s add this
  (route/not-found "Not Found"))
#+END_SRC

Now save the file. The build pipeline detects the change, and restarts the backend system automatically.

In the browser, type [[http://localhost:3000/foo]]. Voilà. A new route is born. This demonstrates the workflow in the backend. Now let’s do a change client-side. Open ~src/cljs/real_time/core.cljs~ and on line 26 change the string for Value from “submit” to “send”. Save the file. The change is reflected automatically in the browser.

Do you feel the creative juices flow? Aren’t you all set to dive in the zone for endless hours of sheer creative output?!
